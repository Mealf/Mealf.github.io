[{"categories":["LeetCode"],"content":"問題描述 ","date":"2022-01-20","objectID":"/leetcode875/:1:0","tags":["LeetCode"],"title":"LeetCode 875. Koko Eating Bananas","uri":"/leetcode875/"},{"categories":["LeetCode"],"content":"分類： Medium ","date":"2022-01-20","objectID":"/leetcode875/:1:1","tags":["LeetCode"],"title":"LeetCode 875. Koko Eating Bananas","uri":"/leetcode875/"},{"categories":["LeetCode"],"content":"相關主題： Array、 Binary Search ","date":"2022-01-20","objectID":"/leetcode875/:1:2","tags":["LeetCode"],"title":"LeetCode 875. Koko Eating Bananas","uri":"/leetcode875/"},{"categories":["LeetCode"],"content":"Link： https://leetcode.com/problems/koko-eating-bananas/ ","date":"2022-01-20","objectID":"/leetcode875/:1:3","tags":["LeetCode"],"title":"LeetCode 875. Koko Eating Bananas","uri":"/leetcode875/"},{"categories":["LeetCode"],"content":"題目敘述 Koko loves to eat bananas. There are n piles of bananas, the ith pile has piles[i] bananas. The guards have gone and will come back in h hours. Koko can decide her bananas-per-hour eating speed of k. Each hour, she chooses some pile of bananas and eats k bananas from that pile. If the pile has less than k bananas, she eats all of them instead and will not eat any more bananas during this hour. Koko likes to eat slowly but still wants to finish eating all the bananas before the guards return. Return the minimum integer k such that she can eat all the bananas within h hours. ","date":"2022-01-20","objectID":"/leetcode875/:1:4","tags":["LeetCode"],"title":"LeetCode 875. Koko Eating Bananas","uri":"/leetcode875/"},{"categories":["LeetCode"],"content":"測資 Example 1: Input: piles = [3,6,7,11], h = 8 Output: 4 Example 2: Input: piles = [30,11,23,4,20], h = 5 Output: 30 Example 3: Input: piles = [30,11,23,4,20], h = 6 Output: 23 ","date":"2022-01-20","objectID":"/leetcode875/:1:5","tags":["LeetCode"],"title":"LeetCode 875. Koko Eating Bananas","uri":"/leetcode875/"},{"categories":["LeetCode"],"content":"解題方法 原本看到題目沒有甚麼解題的想法，去稍微看一下 Related Topics 找個提示，看到裡面有 Binary Search 的標籤後就稍微有點想法了。 既然它要 Binary Search，那其中要調整的值就是題目所求的 k(速度)，再來就是去找出調整這個 k 方法，這個k值的最小值為1，最大值為陣列中最大的值。 我們可以去拿這個 k 去計算出這個 k 所需要的時間，若算出來的時間比題目上限要小，可以將吃香蕉的速度放慢，也就是將 k 值調小，反之則調大。 在這個題目中，我無意中寫出了有向上取整效果的作法，不過好像只有在正數時才有這個效果。 (x + y - 1) / y ","date":"2022-01-20","objectID":"/leetcode875/:2:0","tags":["LeetCode"],"title":"LeetCode 875. Koko Eating Bananas","uri":"/leetcode875/"},{"categories":["LeetCode"],"content":"程式碼 class Solution { public: int minEatingSpeed(vector\u003cint\u003e\u0026 piles, int h) { int left = 1, right=0, mid, eat_time; for(auto pile: piles) { right = max(right, pile); } while(left \u003c right) { mid = (left+right)/2; eat_time = hourForEat(piles, mid); if(eat_time \u003e h) left = mid+1; else right = mid; } return right; } int hourForEat(vector\u003cint\u003e\u0026 piles, int speed) { int hour = 0; for(auto pile: piles) { hour += (pile+speed-1) / speed; } return hour; } }; ","date":"2022-01-20","objectID":"/leetcode875/:2:1","tags":["LeetCode"],"title":"LeetCode 875. Koko Eating Bananas","uri":"/leetcode875/"},{"categories":["LeetCode"],"content":"結果 ","date":"2022-01-20","objectID":"/leetcode875/:2:2","tags":["LeetCode"],"title":"LeetCode 875. Koko Eating Bananas","uri":"/leetcode875/"},{"categories":["LeetCode"],"content":"問題描述 ","date":"2022-01-20","objectID":"/leetcode142/:1:0","tags":["LeetCode"],"title":"LeetCode 142. Linked List Cycle II","uri":"/leetcode142/"},{"categories":["LeetCode"],"content":"分類： Easy ","date":"2022-01-20","objectID":"/leetcode142/:1:1","tags":["LeetCode"],"title":"LeetCode 142. Linked List Cycle II","uri":"/leetcode142/"},{"categories":["LeetCode"],"content":"相關主題： Hash Table、 Linked List、 Two Pointers ","date":"2022-01-20","objectID":"/leetcode142/:1:2","tags":["LeetCode"],"title":"LeetCode 142. Linked List Cycle II","uri":"/leetcode142/"},{"categories":["LeetCode"],"content":"Link： https://leetcode.com/problems/linked-list-cycle-ii/ ","date":"2022-01-20","objectID":"/leetcode142/:1:3","tags":["LeetCode"],"title":"LeetCode 142. Linked List Cycle II","uri":"/leetcode142/"},{"categories":["LeetCode"],"content":"題目敘述 Given the head of a linked list, return the node where the cycle begins. If there is no cycle, return null. There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. Internally, pos is used to denote the index of the node that tail’s next pointer is connected to (0-indexed). It is -1 if there is no cycle. Note that pos is not passed as a parameter. Do not modify the linked list. ","date":"2022-01-20","objectID":"/leetcode142/:1:4","tags":["LeetCode"],"title":"LeetCode 142. Linked List Cycle II","uri":"/leetcode142/"},{"categories":["LeetCode"],"content":"測資 Input: head = [3,2,0,-4], pos = 1 Output: tail connects to node index 1 Explanation: There is a cycle in the linked list, where tail connects to the second node. ","date":"2022-01-20","objectID":"/leetcode142/:1:5","tags":["LeetCode"],"title":"LeetCode 142. Linked List Cycle II","uri":"/leetcode142/"},{"categories":["LeetCode"],"content":"解題方法 ","date":"2022-01-20","objectID":"/leetcode142/:2:0","tags":["LeetCode"],"title":"LeetCode 142. Linked List Cycle II","uri":"/leetcode142/"},{"categories":["LeetCode"],"content":"hash table 這題需要我們去找出 list 中出現循環的起點，若 list 中沒有出現循環，則返回空指標。 最直觀的解法就是去使用 hash table， 紀錄出現過的 listNode 之記憶體位址，若再次出現則為循環的起點。 不過這種做法的缺點是要去記錄所有的 node，會使用到較多的空間，速度也較慢。 程式碼 /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public: ListNode *detectCycle(ListNode *head) { unordered_set\u003cListNode*\u003e seen; ListNode *node = head; while(node != nullptr) { if(seen.count(node) == 1) return node; seen.insert(node); node = node-\u003enext; } return nullptr; } }; 結果 ","date":"2022-01-20","objectID":"/leetcode142/:2:1","tags":["LeetCode"],"title":"LeetCode 142. Linked List Cycle II","uri":"/leetcode142/"},{"categories":["LeetCode"],"content":"Fast-Slow pointer 這題我們可以使用快慢指標來判斷是否出現循環，並找出循環的起始點。 Fast pointer 一次移動兩格; Slow pointer 一次移動一格 若他們兩個指標相遇時，表示出現了循環。這時將其中一個指標移到起點，兩個指標每次都只動一格，它們再次相遇時的那個點，就是循環的起始點。 雖然沒有很了解其中的原理，但它就是有這個特殊的性質。 可以從結果中看到，這種解法速度較快，且記憶體使用率也較低。 程式碼 /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public: ListNode *detectCycle(ListNode *head) { ListNode *slow = head; ListNode *fast = head; while(fast \u0026\u0026 fast-\u003enext) { fast = fast-\u003enext-\u003enext; slow = slow-\u003enext; if(fast == slow) break; } if(fast \u0026\u0026 fast-\u003enext) { fast = head; while(fast != slow) { fast = fast-\u003enext; slow = slow-\u003enext; } return fast; } return nullptr; } }; 結果 ","date":"2022-01-20","objectID":"/leetcode142/:2:2","tags":["LeetCode"],"title":"LeetCode 142. Linked List Cycle II","uri":"/leetcode142/"},{"categories":["vCenter"],"content":"在登入vCenter後，上排常常出現密碼將要到期的提示，而且改完後過一段時間又再跳出來了，因此這次想要一勞永逸，不要讓他在強制我們修改密碼，順便做個紀錄。 vCenter 版本: 6.7.0 ","date":"2022-01-14","objectID":"/vcenter_password_expired/:0:0","tags":["vCenter","configuration"],"title":"vCenter 取消密碼到期","uri":"/vcenter_password_expired/"},{"categories":["vCenter"],"content":"介面位置 選擇上方的功能表 -\u003e 系統管理 -\u003e Single Sign On -\u003e 組態 ","date":"2022-01-14","objectID":"/vcenter_password_expired/:1:0","tags":["vCenter","configuration"],"title":"vCenter 取消密碼到期","uri":"/vcenter_password_expired/"},{"categories":["vCenter"],"content":"到期時間設定 可以看到原本密碼90天內需要更變一次，我們可以點選右上方的編輯 將存留時間上限的欄位填0，表示密碼不會到期 如此一來就不會再看到惱人的到期提醒了 ","date":"2022-01-14","objectID":"/vcenter_password_expired/:2:0","tags":["vCenter","configuration"],"title":"vCenter 取消密碼到期","uri":"/vcenter_password_expired/"},{"categories":["vCenter"],"content":"參考資料 https://docs.vmware.com/tw/VMware-vSphere/6.7/com.vmware.psc.doc/GUID-B9C4409A-B053-40C3-96DE-232BB99AAA35.html ","date":"2022-01-14","objectID":"/vcenter_password_expired/:3:0","tags":["vCenter","configuration"],"title":"vCenter 取消密碼到期","uri":"/vcenter_password_expired/"}]