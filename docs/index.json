[{"categories":["網路管理"],"content":"錯誤訊息 之前在 Windows 中都能正常的建立 L2TP 的連線，但最近要連線時就出現了以下的錯誤訊息 ","date":"2022-01-25","objectID":"/winl2tp_error/:1:0","tags":["windows","L2TP","VPN"],"title":"Windows 10 L2TP 解決連線失敗","uri":"/winl2tp_error/"},{"categories":["網路管理"],"content":"排錯過程 先使用 ubuntu 與 anandroid 環境建立 L2TP 連線，皆能成功連線，同時也在相同的網路環境中進行測試，排除了網路的影響，且在別的 OS 中也能連線，也排除了 Server 端的異常。 因此就針對 Windows 環境下去搜尋，在網路上看到許多修改機碼的方法，但說實話我對這些方法並不抱著多大的期待，畢竟在之前還能正常連線，在照著網路的步驟做之後，果然一點用也沒有。 最後在網路上看到一個月之內發布的文章，裡面談到了這是因為 Windows 的更新(KB5009543) 所造成。 我就依據他更新的版本號進行搜尋，在官方的支援文檔中，可以看到 “此更新中的已知問題\"內，有 L2TP 相關的問題，並在 KB5010793 的更新中解決了，所以我們現在的目標就是要將我們的Windows更新到對應的版本 ","date":"2022-01-25","objectID":"/winl2tp_error/:2:0","tags":["windows","L2TP","VPN"],"title":"Windows 10 L2TP 解決連線失敗","uri":"/winl2tp_error/"},{"categories":["網路管理"],"content":"解決方法 ","date":"2022-01-25","objectID":"/winl2tp_error/:3:0","tags":["windows","L2TP","VPN"],"title":"Windows 10 L2TP 解決連線失敗","uri":"/winl2tp_error/"},{"categories":["網路管理"],"content":"Windows 10 更新到 KB5010793 版本 不想更新的話，退個版本也個是辦法。 對 Windows 進行更新，先更新到 21H2 版本 在更新成 21H2 後，先按一次檢查更新，他就能夠更新到 KB5010793 了 在更新完成後，就能正常連線了 ","date":"2022-01-25","objectID":"/winl2tp_error/:3:1","tags":["windows","L2TP","VPN"],"title":"Windows 10 L2TP 解決連線失敗","uri":"/winl2tp_error/"},{"categories":["網路管理"],"content":"參考資料 https://www.reddit.com/r/sysadmin/comments/s1oqv8/kb5009543_january_11_2022_breaks_l2tp_vpn/ https://support.microsoft.com/zh-tw/topic/2022-%E5%B9%B4-1-%E6%9C%88-11-%E6%97%A5-kb5009543-os-%E7%89%88%E6%9C%AC-19042-1466-19043-1466-%E5%92%8C-19044-1466-b763552f-73bd-435a-b220-fc3e0bc9765b https://support.microsoft.com/zh-tw/topic/2022-%E5%B9%B4-1-%E6%9C%88-17-%E6%97%A5-kb5010793-os-%E7%89%88%E6%9C%AC-19042-1469-19043-1469-%E5%92%8C-19044-1469-%E5%B8%B6%E5%A4%96-f2d4f178-5b36-49cb-a6fd-4bf9857574f9 ","date":"2022-01-25","objectID":"/winl2tp_error/:4:0","tags":["windows","L2TP","VPN"],"title":"Windows 10 L2TP 解決連線失敗","uri":"/winl2tp_error/"},{"categories":["LeetCode"],"content":"問題描述 ","date":"2022-01-20","objectID":"/leetcode875/:1:0","tags":["LeetCode"],"title":"LeetCode 875. Koko Eating Bananas","uri":"/leetcode875/"},{"categories":["LeetCode"],"content":"分類： Medium ","date":"2022-01-20","objectID":"/leetcode875/:1:1","tags":["LeetCode"],"title":"LeetCode 875. Koko Eating Bananas","uri":"/leetcode875/"},{"categories":["LeetCode"],"content":"相關主題： Array、 Binary Search ","date":"2022-01-20","objectID":"/leetcode875/:1:2","tags":["LeetCode"],"title":"LeetCode 875. Koko Eating Bananas","uri":"/leetcode875/"},{"categories":["LeetCode"],"content":"Link： https://leetcode.com/problems/koko-eating-bananas/ ","date":"2022-01-20","objectID":"/leetcode875/:1:3","tags":["LeetCode"],"title":"LeetCode 875. Koko Eating Bananas","uri":"/leetcode875/"},{"categories":["LeetCode"],"content":"題目敘述 Koko loves to eat bananas. There are n piles of bananas, the ith pile has piles[i] bananas. The guards have gone and will come back in h hours. Koko can decide her bananas-per-hour eating speed of k. Each hour, she chooses some pile of bananas and eats k bananas from that pile. If the pile has less than k bananas, she eats all of them instead and will not eat any more bananas during this hour. Koko likes to eat slowly but still wants to finish eating all the bananas before the guards return. Return the minimum integer k such that she can eat all the bananas within h hours. ","date":"2022-01-20","objectID":"/leetcode875/:1:4","tags":["LeetCode"],"title":"LeetCode 875. Koko Eating Bananas","uri":"/leetcode875/"},{"categories":["LeetCode"],"content":"測資 Example 1: Input: piles = [3,6,7,11], h = 8 Output: 4 Example 2: Input: piles = [30,11,23,4,20], h = 5 Output: 30 Example 3: Input: piles = [30,11,23,4,20], h = 6 Output: 23 ","date":"2022-01-20","objectID":"/leetcode875/:1:5","tags":["LeetCode"],"title":"LeetCode 875. Koko Eating Bananas","uri":"/leetcode875/"},{"categories":["LeetCode"],"content":"解題方法 原本看到題目沒有甚麼解題的想法，去稍微看一下 Related Topics 找個提示，看到裡面有 Binary Search 的標籤後就稍微有點想法了。 既然它要 Binary Search，那其中要調整的值就是題目所求的 k(速度)，再來就是去找出調整這個 k 方法，這個k值的最小值為1，最大值為陣列中最大的值。 我們可以去拿這個 k 去計算出這個 k 所需要的時間，若算出來的時間比題目上限要小，可以將吃香蕉的速度放慢，也就是將 k 值調小，反之則調大。 在這個題目中，我無意中寫出了有向上取整效果的作法，不過好像只有在正數時才有這個效果。 (x + y - 1) / y ","date":"2022-01-20","objectID":"/leetcode875/:2:0","tags":["LeetCode"],"title":"LeetCode 875. Koko Eating Bananas","uri":"/leetcode875/"},{"categories":["LeetCode"],"content":"程式碼 class Solution { public: int minEatingSpeed(vector\u003cint\u003e\u0026 piles, int h) { int left = 1, right=0, mid, eat_time; for(auto pile: piles) { right = max(right, pile); } while(left \u003c right) { mid = (left+right)/2; eat_time = hourForEat(piles, mid); if(eat_time \u003e h) left = mid+1; else right = mid; } return right; } int hourForEat(vector\u003cint\u003e\u0026 piles, int speed) { int hour = 0; for(auto pile: piles) { hour += (pile+speed-1) / speed; } return hour; } }; ","date":"2022-01-20","objectID":"/leetcode875/:2:1","tags":["LeetCode"],"title":"LeetCode 875. Koko Eating Bananas","uri":"/leetcode875/"},{"categories":["LeetCode"],"content":"結果 ","date":"2022-01-20","objectID":"/leetcode875/:2:2","tags":["LeetCode"],"title":"LeetCode 875. Koko Eating Bananas","uri":"/leetcode875/"},{"categories":["LeetCode"],"content":"問題描述 ","date":"2022-01-20","objectID":"/leetcode142/:1:0","tags":["LeetCode"],"title":"LeetCode 142. Linked List Cycle II","uri":"/leetcode142/"},{"categories":["LeetCode"],"content":"分類： Easy ","date":"2022-01-20","objectID":"/leetcode142/:1:1","tags":["LeetCode"],"title":"LeetCode 142. Linked List Cycle II","uri":"/leetcode142/"},{"categories":["LeetCode"],"content":"相關主題： Hash Table、 Linked List、 Two Pointers ","date":"2022-01-20","objectID":"/leetcode142/:1:2","tags":["LeetCode"],"title":"LeetCode 142. Linked List Cycle II","uri":"/leetcode142/"},{"categories":["LeetCode"],"content":"Link： https://leetcode.com/problems/linked-list-cycle-ii/ ","date":"2022-01-20","objectID":"/leetcode142/:1:3","tags":["LeetCode"],"title":"LeetCode 142. Linked List Cycle II","uri":"/leetcode142/"},{"categories":["LeetCode"],"content":"題目敘述 Given the head of a linked list, return the node where the cycle begins. If there is no cycle, return null. There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. Internally, pos is used to denote the index of the node that tail’s next pointer is connected to (0-indexed). It is -1 if there is no cycle. Note that pos is not passed as a parameter. Do not modify the linked list. ","date":"2022-01-20","objectID":"/leetcode142/:1:4","tags":["LeetCode"],"title":"LeetCode 142. Linked List Cycle II","uri":"/leetcode142/"},{"categories":["LeetCode"],"content":"測資 Input: head = [3,2,0,-4], pos = 1 Output: tail connects to node index 1 Explanation: There is a cycle in the linked list, where tail connects to the second node. ","date":"2022-01-20","objectID":"/leetcode142/:1:5","tags":["LeetCode"],"title":"LeetCode 142. Linked List Cycle II","uri":"/leetcode142/"},{"categories":["LeetCode"],"content":"解題方法 ","date":"2022-01-20","objectID":"/leetcode142/:2:0","tags":["LeetCode"],"title":"LeetCode 142. Linked List Cycle II","uri":"/leetcode142/"},{"categories":["LeetCode"],"content":"hash table 這題需要我們去找出 list 中出現循環的起點，若 list 中沒有出現循環，則返回空指標。 最直觀的解法就是去使用 hash table， 紀錄出現過的 listNode 之記憶體位址，若再次出現則為循環的起點。 不過這種做法的缺點是要去記錄所有的 node，會使用到較多的空間，速度也較慢。 程式碼 /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public: ListNode *detectCycle(ListNode *head) { unordered_set\u003cListNode*\u003e seen; ListNode *node = head; while(node != nullptr) { if(seen.count(node) == 1) return node; seen.insert(node); node = node-\u003enext; } return nullptr; } }; 結果 ","date":"2022-01-20","objectID":"/leetcode142/:2:1","tags":["LeetCode"],"title":"LeetCode 142. Linked List Cycle II","uri":"/leetcode142/"},{"categories":["LeetCode"],"content":"Fast-Slow pointer 這題我們可以使用快慢指標來判斷是否出現循環，並找出循環的起始點。 Fast pointer 一次移動兩格; Slow pointer 一次移動一格 若他們兩個指標相遇時，表示出現了循環。這時將其中一個指標移到起點，兩個指標每次都只動一格，它們再次相遇時的那個點，就是循環的起始點。 雖然沒有很了解其中的原理，但它就是有這個特殊的性質。 可以從結果中看到，這種解法速度較快，且記憶體使用率也較低。 程式碼 /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public: ListNode *detectCycle(ListNode *head) { ListNode *slow = head; ListNode *fast = head; while(fast \u0026\u0026 fast-\u003enext) { fast = fast-\u003enext-\u003enext; slow = slow-\u003enext; if(fast == slow) break; } if(fast \u0026\u0026 fast-\u003enext) { fast = head; while(fast != slow) { fast = fast-\u003enext; slow = slow-\u003enext; } return fast; } return nullptr; } }; 結果 ","date":"2022-01-20","objectID":"/leetcode142/:2:2","tags":["LeetCode"],"title":"LeetCode 142. Linked List Cycle II","uri":"/leetcode142/"},{"categories":["網路管理"],"content":"在登入vCenter後，上排常常出現密碼將要到期的提示，而且改完後過一段時間又再跳出來了，因此這次想要一勞永逸，不要讓他在強制我們修改密碼，順便做個紀錄。 vCenter 版本: 6.7.0 ","date":"2022-01-14","objectID":"/vcenter_password_expired/:0:0","tags":["vCenter","configuration"],"title":"vCenter 取消密碼到期","uri":"/vcenter_password_expired/"},{"categories":["網路管理"],"content":"介面位置 選擇上方的功能表 -\u003e 系統管理 -\u003e Single Sign On -\u003e 組態 ","date":"2022-01-14","objectID":"/vcenter_password_expired/:1:0","tags":["vCenter","configuration"],"title":"vCenter 取消密碼到期","uri":"/vcenter_password_expired/"},{"categories":["網路管理"],"content":"到期時間設定 可以看到原本密碼90天內需要更變一次，我們可以點選右上方的編輯 將存留時間上限的欄位填0，表示密碼不會到期 如此一來就不會再看到惱人的到期提醒了 ","date":"2022-01-14","objectID":"/vcenter_password_expired/:2:0","tags":["vCenter","configuration"],"title":"vCenter 取消密碼到期","uri":"/vcenter_password_expired/"},{"categories":["網路管理"],"content":"參考資料 https://docs.vmware.com/tw/VMware-vSphere/6.7/com.vmware.psc.doc/GUID-B9C4409A-B053-40C3-96DE-232BB99AAA35.html ","date":"2022-01-14","objectID":"/vcenter_password_expired/:3:0","tags":["vCenter","configuration"],"title":"vCenter 取消密碼到期","uri":"/vcenter_password_expired/"}]